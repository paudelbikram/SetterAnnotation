An annotation is a kind of meta data in java which can be
applied to various elements of Java sourcecode so that later
some tool, debugger or application program can take advantage of these
annotations; and help analyze the program in positive and constructive way.
We can annotate almost anything in Java. It is important to learn that
the annotations applied on java sourcecode is compiled into bytecode with other
class members, and using reflection programmer can query this meta data information to
decide the appropriate action to perform in any particular context.


Built-in Annotations in Java:
Annotations that are applied to other annotations:

1. @Retention:
    This annotation specifies how the marked annotation is stored in java runtime. Whether it is
    limited to source code only, embedded into the generated class file, or it will be available at
    runtime through reflection as well.

    @Retention(RetentionPolicy.CLASS)
    @Retention(RetentionPolicy.RUNTIME)
    @Retention(RetentionPolicy.SOURCE)

2. @Documented:
    This indicates that new annotation should be included into java documents
    generated by java document generators tools.

3. @Target:
    This restricts the usage of new annotation on certain java elements.

    @Target(value = {ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR,
                     ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.LOCAL_VARIABLE,
                     ElementType.PACKAGE, ElementType.PARAMETER})

4. @Inherited:
    This means if annotation is applied to parent class. Then, they are also going to be available in child classes.

5. @Repeatable:
    By default, an annotation is applied on a java element only once. But, by any requirement, you
    have to apply a annotation more than once, then use @Repeatable annotation on your new annotation.

    @Repeatable(Schedules.class)
    public @interface Schedule { ... }

    @Schedule(dayOfMonth="last")
    @Schedule(dayOfWeek="Fri", hour="23")
    public void doPeriodicCleanup() { ... }



Annotations Applied To Java Code:
1. @Override
2. @Deprecated
3. @SuppressWarning
4. @SafeVarargs
5. @FunctionalInterface


Reading Annotations at compile-time using Java Annotation Processors:
    https://medium.com/@nadundesilva/reading-annotations-at-compile-time-using-java-annotation-processors-f5a7604bb2f7

    An annotation processor can be implemented by extending the
    javax.annotation.processing.AbstractProcessor class. The annotation
    processors are invoked during compile time and we can generated code,
    validate etc using it.

    public class AnnotationProcessorExample extends AbstractProcessor {
        @Override
        public synchronized void init(ProcessingEnvironment env) {
            // Initialize the processor
        }
        @Override
        public boolean process(Set<? extends TypeElement> set,
                               RoundEnvironment roundEnv) {
            // Process the annotation
        }
        @Override
        public Set<String> getSupportedAnnotationTypes() {
            // Return the set of annotations supported
        }
        @Override
        public SourceVersion getSupportedSourceVersion() {
            // Return the Java version supported
        }
    }

    init(): This gives you instances of different utilities which are useful for
    code generation.
        Filler: used to create new source, class or auxiliary files.
        Messager: used to report errors, warning and other notices
        Element Utils: utility methods used for operating on elements
        Type Utils: Utility methods used for operating on types
        Locale: If a Locale is in effect it will be provided. This can be useful if you are
            developing a Locale specific application.

    process(): We will have access to the class elements in this method.
    We can perform any changes to the source files, validate code, generate code,
    etc. using this method.

    getSupportedAnnotationTypes(): We need to return the list of annotations that are
    supported by this processor. The elements to which the annotation processor will have
    access to is determined by this.

    getSupportedSourceVersion(): The Java version the annotation processor is supposed to
    support.


Engaging the Annotation Processor:
1. Using teh Compiler Key:
    If you are compiling your Java source code by invoking the
    javac command, you can using -processor argument to engage the
    annotation processors. A comma separated list of annotation processors
    need to be passed to use the annotation processors at compile time.

    javac -processor com.foo.FooProcessor,com.bar.BarProcessor MyClassWithAnnotations.java

2. Using Maven:
    If you are using Maven for building the source files, the following can be
    added to you pom.xml file to engage the annotation processor.

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.5.1</version>
                <configuration>
                    <!-- Other configurations -->
                    <annotationProcessors>
                        <annotationProcessor>
                            com.foo.FooProcessor
                        </annotationProcessor>
                    </annotationProcessors>
                </configuration>
            </plugin>
        </plugins>
    </build>

3. Adding the Processor to the class path:
    If you prefer the annotation processor to be picked up automatically, we need to add the
    fully qualified class names of the Annotation Processors to the
    META-INF/services/javax.annotation.processing.Processor file

    com.foo.FooProcessor
    com.bar.BarProcessor

